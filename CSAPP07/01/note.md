为了更好地解释链接器的符号解析和重定位功能，让我们考虑一个简单的示例，其中包含两个 C 语言源文件：`main.c` 和 `sum.c`。

### 文件内容
假设我们有以下源文件：

**main.c**
```c
#include <stdio.h>

extern int sum(int *, int); // 引用符号

int main() {
    int array[2] = {1, 2};
    int result = sum(array, 2); // 对 sum 函数的引用
    printf("Result is %d\n", result);
    return 0;
}
```

**sum.c**
```c
int sum(int *array, int n) { // 定义符号
    int total = 0;
    for (int i = 0; i < n; i++) {
        total += array[i];
    }
    return total;
}
```

### 1. 符号解析（Symbol Resolution）

在这个例子中，`main.c` 引用了一个符号 `sum`，这个符号是一个函数。这个函数在 `sum.c` 中被定义。
在编译阶段，编译器不知道 `sum` 函数的具体位置，它仅仅知道有一个符号叫做 `sum` 需要在之后的某个时刻解析。

当链接器处理这两个对象文件时，它执行符号解析的步骤：

- 它发现 `main.o` 引用了一个名为 `sum` 的符号。
- 它在 `sum.o` 中找到了 `sum` 的定义。
- 链接器将 `main.o` 中对 `sum` 的引用和 `sum.o` 中 `sum` 的定义关联起来。

### 2. 重定位（Relocation）

每个源文件编译成对象文件时，编译器和汇编器生成的代码和数据是从地址 0 开始的。
这意味着，编译器生成的每个对象文件都假设自己是从内存的 0 地址开始的。
但实际上，这些代码和数据不能都放在相同的内存地址。链接器的任务是将这些分散的代码和数据片段“重定位”到程序的最终内存中。

在我们的例子中，这意味着：

- `main.o` 和 `sum.o` 中的代码和数据需要被放置在不重叠的内存地址。
- 链接器确定 `sum` 函数的最终地址。
- 链接器修改 `main.o` 中的所有对 `sum` 的引用，使它们指向 `sum` 函数的最终地址。

为了实现这一点，链接器使用了由汇编器生成的重定位条目。这些条目为链接器提供了必要的信息，告诉它需要如何修改代码，以便正确地引用内存中的位置。

### 结论

通过这个过程，链接器确保程序中的每个符号引用都正确地指向其定义，并且每个代码和数据片段都被放置在程序的最终内存布局中的正确位置。这使得生成的可执行文件能够在加载到内存时正常运行，因为所有的内部引用都指向正确的地址。

===================================================================================================

在 Linux 上，您可以使用一系列工具来观察和理解链接过程，特别是符号解析和重定位的部分。这些工具包括编译器（如 `gcc`），反汇编器（如 `objdump`），以及用于查看对象文件和可执行文件的详细信息的工具（如 `nm` 和 `readelf`）。让我们以您之前提到的 `main.c` 和 `sum.c` 为例，逐步展示这个过程：

### 1. 编译源文件
首先，您需要编译源文件以生成对象文件：

```bash
gcc -c main.c -o main.o
gcc -c sum.c -o sum.o
```

### 2. 查看符号
使用 `nm` 工具查看对象文件中的符号。这可以展示出哪些符号被定义，哪些符号是未解析的：

```bash
nm main.o
nm sum.o
```

~~~shell
└─[$]> nm main.o
                 U _GLOBAL_OFFSET_TABLE_
0000000000000000 T main
                 U printf
                 U __stack_chk_fail
                 U sum

└─[$]> nm sum.o
0000000000000000 T sum                 
~~~

在 `main.o` 的输出中，您将看到对 `sum` 函数的引用被标记为未解析（通常显示为 `U`），而在 `sum.o` 的输出中，您将看到 `sum` 被定义。

### 3. 链接对象文件
接下来，链接这些对象文件以创建可执行文件：

```bash
gcc main.o sum.o -o program
```

### 4. 使用 `objdump` 进行反汇编
现在，您可以使用 `objdump` 工具来反汇编可执行文件，查看函数调用和其他指令是如何被重定位的：

```bash
objdump -d program
```

在 `objdump` 的输出中，您可以查找到 `main` 函数中对 `sum` 函数的调用指令。这将展示 `sum` 函数调用的实际地址，表明链接器已经执行了重定位。

~~~shell
┌─[czy@czy-307-thinkcentre-m720q-n000] - [~/new_space/linking_and_loading/CSAPP07/01] - [四 11月 23, 00:10]
└─[$]> objdump -d prog | grep "sum"
    119e:       e8 34 00 00 00          callq  11d7 <sum>
00000000000011d7 <sum>:
    11f4:       eb 1d                   jmp    1213 <sum+0x3c>
    1219:       7c db                   jl     11f6 <sum+0x1f>
~~~

### 5. 查看重定位信息
使用 `readelf` 工具可以查看对象文件或可执行文件的重定位条目。对于对象文件：

```bash
readelf -r main.o
readelf -r sum.o
```

~~~shell
└─[$]> readelf -r main.o

重定位节 '.rela.text' at offset 0x2e8 contains 4 entries:
  偏移量          信息           类型           符号值        符号名称 + 加数
000000000036  000c00000004 R_X86_64_PLT32    0000000000000000 sum - 4
000000000045  000500000002 R_X86_64_PC32     0000000000000000 .rodata - 4
00000000004f  000d00000004 R_X86_64_PLT32    0000000000000000 printf - 4
000000000068  000e00000004 R_X86_64_PLT32    0000000000000000 __stack_chk_fail - 4

重定位节 '.rela.eh_frame' at offset 0x348 contains 1 entry:
  偏移量          信息           类型           符号值        符号名称 + 加数
000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0

└─[$]> readelf -r sum.o

重定位节 '.rela.eh_frame' at offset 0x210 contains 1 entry:
  偏移量          信息           类型           符号值        符号名称 + 加数
000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
~~~

这将展示重定位条目，即链接器需要更新引用地址的地方。

======================输出解读==============================
### main.o 的重定位条目

1. **.rela.text**
   - 这是代码段（text section）的重定位条目。
   - **偏移量**：这是需要重定位的地方在段内的偏移。
   - **信息**和**类型**：这些描述了重定位的类型和相关符号。
   - **符号名称 + 加数**：指明了重定位引用的符号以及任何额外的加数（偏移）。

   在您的输出中，例如 `R_X86_64_PLT32 sum - 4` 表示一个到 `sum` 函数的PLT（过程链接表）项的32位相对地址重定位。这是因为 `main.o` 不能确定 `sum` 函数的最终地址，所以使用了PLT来间接寻址。

2. **.rela.eh_frame**
   - 这是异常处理框架的重定位条目。
   - 它通常与代码的控制流和异常处理有关。

### sum.o 的重定位条目

在 `sum.o` 中，您也看到了 `.rela.eh_frame` 的条目，但没有 `.rela.text` 条目。这是因为 `sum.o` 中的 `sum` 函数没有对外部符号的依赖（例如，没有调用其他外部定义的函数）。

### 理解输出

- **main.o 中的 `sum` 调用**：在链接时，链接器会查看 `main.o` 中到 `sum` 的引用，并将其解析到 `sum.o` 中 `sum` 函数的实际地址。由于在编译时 `main.o` 不知道 `sum` 的地址，所以它使用了一个占位符，这个占位符在链接时被替换成正确的地址。

- **重定位类型**：`R_X86_64_PLT32` 和 `R_X86_64_PC32` 是常见的重定位类型，在 x86_64 架构上表示特定类型的地址修正。

通过这些信息，您可以了解链接器如何根据每个对象文件的重定位条目来调整代码和数据的地址，以确保程序中的所有引用在运行时都是正确的。

===========================================================================================

### 6. 分析链接后的符号表
最后，您可以再次使用 `nm` 工具来查看最终可执行文件中的符号表：

```bash
nm program
```

~~~shell
└─[$]> nm prog   
0000000000004010 B __bss_start
0000000000004010 b completed.8061
                 w __cxa_finalize@@GLIBC_2.2.5
0000000000004000 D __data_start
0000000000004000 W data_start
00000000000010b0 t deregister_tm_clones
0000000000001120 t __do_global_dtors_aux
0000000000003db8 d __do_global_dtors_aux_fini_array_entry
0000000000004008 D __dso_handle
0000000000003dc0 d _DYNAMIC
0000000000004010 D _edata
0000000000004018 B _end
0000000000001298 T _fini
0000000000001160 t frame_dummy
0000000000003db0 d __frame_dummy_init_array_entry
0000000000002184 r __FRAME_END__
0000000000003fb0 d _GLOBAL_OFFSET_TABLE_
                 w __gmon_start__
0000000000002014 r __GNU_EH_FRAME_HDR
0000000000001000 t _init
0000000000003db8 d __init_array_end
0000000000003db0 d __init_array_start
0000000000002000 R _IO_stdin_used
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
0000000000001290 T __libc_csu_fini
0000000000001220 T __libc_csu_init
                 U __libc_start_main@@GLIBC_2.2.5
0000000000001169 T main
                 U printf@@GLIBC_2.2.5
00000000000010e0 t register_tm_clones
                 U __stack_chk_fail@@GLIBC_2.4
0000000000001080 T _start
00000000000011d7 T sum
0000000000004010 D __TMC_END__

┌─[czy@czy-307-thinkcentre-m720q-n000] - [~/new_space/linking_and_loading/CSAPP07/01] - [四 11月 23, 00:10]
└─[$]> nm prog | grep "sum"
00000000000011d7 T sum
~~~


这将展示所有符号的最终地址，包括 `main` 和 `sum` 函数。

通过以上步骤，您可以获得对编译、链接过程中符号解析和重定位的深入理解。这些工具提供了对发生在底层的操作的直观理解。


疑问：重定位表是如何发挥作用的？

可执行文件的重定位条目在程序运行时确保代码和数据的正确引用，特别是在动态链接的环境中。下面是重定位条目在可执行文件中发挥作用的详细流程：

### 可执行文件生成

1. **编译和链接**：
   - 源代码文件被编译成对象文件（`.o` 文件）。
   - 链接器处理对象文件，解析符号引用，执行重定位，生成可执行文件。

2. **重定位条目的创建**：
   - 在链接过程中，链接器创建重定位条目。
   这些条目包含了必要的信息，指示如何修改代码段或数据段中的引用，以确保它们指向正确的地址。

### 加载和运行

3. **加载可执行文件**：
   - 当您运行一个程序时，操作系统的加载器（loader）将可执行文件加载到内存中。
   - 对于动态链接的程序，加载器还负责加载所有必要的共享库。

4. **运行时重定位**（对于动态链接的程序）：
   - 加载器使用可执行文件中的重定位条目来调整代码和数据的内存地址，特别是对共享库函数和变量的引用。
   - 例如，如果一个程序调用了动态链接库中的函数，那么在加载时，这个函数调用的地址需要根据实际加载的库函数的地址进行调整。

5. **重定位条目的使用**：
   - 每个重定位条目描述了一个特定的修改：它指定了需要修改的内存位置（偏移量）以及如何修改它（基于符号的最终地址和可能的加数）。
   - 加载器遍历所有重定位条目，按照它们的指示更新内存中的代码和数据。
   - 这确保了所有的符号引用（如函数调用、全局变量等）都被更新为它们在内存中的实际地址。

### 动态链接和共享库

6. **动态链接特点**：
   - 动态链接的程序在运行时与共享库（如动态链接库 `.so` 文件）进行绑定。
   - 加载器不仅需要处理程序的重定位，还需要处理每个共享库的重定位。

### 总结

在这个过程中，重定位条目是确保程序在内存中正确引用代码和数据的关键。
它们使得程序可以灵活地与不同的地址空间和共享库协同工作，特别是在动态链接的环境下，这是非常重要的。
重定位条目让操作系统的加载器能够调整程序的内部引用，确保程序在任何时候都能正确访问其代码和数据。








====================================================================================
重定位节 '.rela.text' at offset 0x2e8 contains 4 entries:
  偏移量          信息           类型           符号值        符号名称 + 加数
000000000036  000c00000004 R_X86_64_PLT32    0000000000000000 sum - 4
====================================================================================

以您提供的重定位条目为例，我们可以详细解释运行时重定位 `sum` 函数的过程。这里关注的主要是 `.rela.text` 部分的第一个条目，它涉及 `sum` 函数。

### 重定位条目分析

**条目**:
```
000000000036  000c00000004 R_X86_64_PLT32    0000000000000000 sum - 4
```

- **偏移量（000000000036）**：这是需要重定位的代码在代码段（.text）中的偏移地址。
- **信息（000c00000004）**：这通常包含重定位类型和相关符号的索引。
- **类型（R_X86_64_PLT32）**：这表示一个 32 位的 PLT (过程链接表) 相对地址重定位。这种类型的重定位用于动态链接。
- **符号名称 + 加数（sum - 4）**：这指明了重定位引用的符号（在这里是 `sum` 函数）以及加数（在这里是 -4）。

### 运行时重定位过程

1. **加载可执行文件**:
   - 操作系统的加载器（loader）将可执行文件加载到内存中。
   - 加载器识别出需要重定位的部分，根据重定位条目进行操作。

2. **定位 `.text` 段**:
   - 加载器定位到代码段（.text）。

3. **应用重定位条目**:
   - 加载器查找到偏移量 `0x36` 处的代码，这是对 `sum` 函数的调用指令所在的位置。
   - 加载器检查重定位类型 `R_X86_64_PLT32`。对于 PLT 重定位，加载器会查找或创建 `sum` 函数的 PLT 条目。
     PLT 条目是一个小的代码片段，用于跳转到正确的函数地址。
   - 加载器将调用指令修改为跳转到 `sum` 函数的 PLT 条目。如果 `sum` 函数在动态库中，则PLT条目在首次调用时会解析到动态库中 `sum` 的实际地址。

4. **调用 `sum` 函数**:
   - 程序运行时，当执行到该调用指令，会跳转到 PLT 条目，然后根据 PLT 条目的指示跳转到 `sum` 函数的实际地址执行。

### 总结

这个重定位条目的主要作用是调整程序中对 `sum` 函数的调用，使其指向正确的地址。对于动态链接的函数，这通常涉及到使用 PLT 来间接寻址，特别是在首次调用时，PLT 条目可能会触发动态链接器来解析函数的实际地址。通过这种方式，程序即使在不同的地址空间或与不同版本的共享库一起加载时，也能正确地调用到所需的函数。
# Dynamic Linking with Shared Libraries
动态链接共享库

我们在 7.6.2 节中研究的静态库解决了许多关于如何让大量相关函数对应用程序可用的问题。
然而，静态库仍然有一些明显的缺点。静态库和所有的软件一样，需要定期维护和更新。如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与更新了的库重新链接。

另一个问题是几乎每个 C 程序都使用标准 I/O 函数，比如 `printf` 和 `scanf`。在运行时，这些函数的代码会被复制到每个运行进程的文本段中。
在一个运行上百个进程的典型系统上，这将是对稀缺的内存系统资源的极大浪费。
> 内存的一个有趣属性就是不论系统的内存有多大，它总是一种稀缺资源。磁盘空间和厨房的垃圾桶同样有这种属性。


====================================================================================================
静态库虽然在某些情况下有优势，比如简化了部署过程，因为所有需要的代码都已经编译进了最终的可执行文件中，但也存在一些明显的缺点，特别是在维护和更新方面：

1. **需要定期维护和更新**：
   - 静态库包含的是库代码的副本，这意味着一旦库更新，所有使用该库的应用程序也需要更新才能利用到库的最新版本。
   - 对于安全更新尤为重要，因为老版本的库可能包含安全漏洞，而静态链接的应用程序不会自动继承库的安全修补。

2. **了解库的更新情况**：
   - 应用程序员需要主动关注他们所使用的静态库的更新情况。这可能涉及到定期检查库的新版本、阅读更新日志、订阅通知服务等。
   - 与此相比，动态库的更新通常由系统的包管理器处理，应用程序自动或轻松地继承这些更新。

3. **重新链接程序**：
   - 一旦静态库更新，应用程序需要重新编译和链接以包含最新版本的库代码。这不仅增加了开发者的工作量，也可能引入新的兼容性问题或其他意外错误。
   - 动态链接的应用程序可以自动从系统范围的库更新中受益，而不需要重新编译或链接。

4. **二进制大小**：
   - 静态链接的应用程序通常体积更大，因为它们包含了所有使用的静态库的代码。这不仅占用更多磁盘空间，也可能影响加载和启动时间。

5. **共享和重用**：
   - 在多个应用程序间共享静态库是不可行的。每个应用程序都有自己的库副本，这意味着即使多个应用程序使用同一个库，它们也各自占用相应的内存空间。
   - 动态库则可以被系统中多个应用程序共享，节省内存。

综上所述，静态库虽然在某些情况下提供了便利，但在维护和更新方面存在一些挑战，特别是在快速发展和频繁更新的软件环境中。这就是为什么许多现代应用倾向于使用动态链接库。
====================================================================================================
静态链接和动态链接是程序构建过程中的两种不同的链接方法，它们各有特点和适用场景。让我们通过一个通俗的例子来解释它们之间的区别：

### 静态链接
想象你正在建造一栋房子，这栋房子需要一些标准化的部件，比如窗户、门和橱柜。

在静态链接的情况下，这就像是你提前制作或购买了这些部件，并将它们永久地安装在房子中。一旦房子建成，这些部件就成为了房子的一部分，无法轻易更换。如果你想更换一个新的窗户样式，你需要拆除旧的窗户，然后安装一个新的窗户，这涉及到对整个房子的重新工作。

在软件中，静态链接意味着所有需要的库（代码部件）在编译时被复制并嵌入到最终的可执行文件中。这使得最终的程序体积变大，但它包含了所有它需要的东西，不依赖于外部的库文件。

### 动态链接
相对地，动态链接就像是你的房子使用了一些标准化的接口来安装窗户和门。这意味着你可以随时更换窗户或门，只要新的部件符合这些标准化的接口。如果市场上出现了一种更好的窗户，你可以简单地卸下旧的窗户并安装新的窗户，而不需要对整个房子进行重建。

在软件中，动态链接意味着程序在编译时并没有包含它需要的所有库。相反，它在运行时从操作系统中加载所需的库。如果库更新了，程序可以利用新版本的库而无需重新编译。这使得程序体积更小，更新更容易，但它需要在运行环境中有相应的库。

### 总结
- **静态链接**：所有需要的代码在编译时被整合进最终的可执行文件，使其独立于外部库。类似于把所有部件永久地固定在房子中。
- **动态链接**：程序运行时从外部加载库。这就像是可以随时更换的标准化窗户和门。

静态链接的程序更独立，但体积更大且更新麻烦；动态链接的程序体积更小，更新更灵活，但依赖于外部的库文件。
====================================================================================================



共享库（*shared library*）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接（dynamic linking），是由一个叫做动态链接器（*dynamic linker*）的程序来执行的。共享库也称为共享目标（*shared object*），在 Linux 系统中通常用 `.so` 后缀来表示。微软的操作系统大量地使用了共享库，它们称为 `DLL`（动态链接库）。

共享库是以两种不同的方式来“共享”的。
 - 首先，在任何给定的文件系统中，对于一个库只有一个`.so` 文件。所有引用该库的可执行目标文件共享这个 `.so` 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。
 - 其次，在内存中，一个共享库的 `.text` 节的一个副本可以被不同的正在运行的进程共享。
 在第 9 章我们学习虚拟内存时将更加详细地讨论这个问题。


程序在动态链接 `libc.so`（C 标准库的动态版本）之前，实际上并不会静态链接其重定位和符号表信息。这里涉及到的是动态链接过程中的一些细节，它们和静态链接有所不同。

在动态链接的情况下，程序的可执行文件在编译时并不包含库（如 `libc.so`）的代码。相反，它包含对这些库中函数和变量的引用，以及必要的重定位信息和符号表，这些信息用于在运行时解析和链接这些外部符号。

### 动态链接过程简述：

1. **编译时**:
   - 当程序被编译成可执行文件时，编译器知道程序使用了 `libc.so` 中的函数，但它不会把 `libc.so` 的代码包含进可执行文件。
   - 编译器会在可执行文件中包含重定位表和符号表，这些表包含了对 `libc.so` 中函数和变量的引用信息。

2. **加载时**:
   - 当程序启动时，动态链接器（如 `ld-linux.so`）会加载程序的可执行文件。
   - 链接器查看程序的重定位表和符号表，确定程序需要哪些库（比如 `libc.so`）。

3. **运行时动态链接**:
   - 动态链接器加载 `libc.so` 到内存中（如果尚未加载）。
   - 链接器解析可执行文件中的符号引用，将它们与 `libc.so` 中相应的函数和变量地址相关联。
   - 如果有必要，链接器会进行重定位，确保引用指向正确的内存地址。

### 关键点
- 程序本身并不包含 `libc.so` 的代码。相反，它有一张表（符号表），列出了它需要从 `libc.so` 中使用的所有函数和变量。
- 程序也有一张重定位表，指示链接器如何调整对这些符号的引用，以便在运行时指向正确的地址。

总的来说，动态链接的程序在编译时并不会静态链接其所依赖的库（如 `libc.so`）的代码，而是保留了必要的信息以在运行时由动态链接器进行实际的链接。

为了构造图 7-6 中示例向量例程的共享库 libvector.so，我们调用编译器驱动程序，给编译器和链接器如下特殊指令

~~~shell
linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c
~~~

~~~c
// addvec.c
int addcnt = 0;

void addvec(int *x, int *y,
            int *z, int n)
{
    int i;
    
    addcnt++;
    
    for ( i = 0; i < n; i++)
        z[i] = x[i] + y[i];
}

// multvec.c
int multcnt = 0;

void multvec(int *x，int *y,
             int *z，int n)
{
    int i;

    multcnt++;

    for (i = 0; i < n; i++)
        z[i] = x[i] * y[i];
}

~~~


这个命令是用于编译并创建一个共享库（动态链接库）的示例，使用了 GCC（GNU 编译器集合）来编译 C 语言源文件。让我们来详细分析这个命令：

- **`-shared`**：这个选项告诉编译器创建一个共享库（动态链接库），而不是一个可执行文件。共享库可以被多个程序同时使用。

- **`-fpic` 或 `-fPIC`**：这代表“位置无关代码”（Position-Independent Code）。在创建共享库时使用这个选项非常重要，因为它允许库中的代码在内存中被任意位置加载。这是动态链接库的一个关键特性，因为它们必须能够被加载到任何使用它们的程序的地址空间中。

将这些放在一起，这个命令创建了一个名为 `libvector.so` 的共享库，其中包含了 `addvec.c` 和 `multvec.c` 源文件中定义的函数。这个库可以被其他程序动态地链接和使用，允许这些程序在运行时共享相同的函数实现。

一旦创建了这个库，随后就要将它链接到图 7-7 的示例程序中：
~~~shell
linux> gcc -o prog2l main2.c ./libvector.so
~~~

这样就创建了一个可执行目标文件 `prog2l`，而此文件的形式使得它在运行时可以和 `libvector.so` 链接。
基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。
认识到这一点是很重要的：此时，没有任何 `libvector.so` 的代码和数据节真的被复制到可执行文件 `prog2l` 中。
反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对 `libvector.so` 中代码和数据的引用。

当加载器加载和运行可执行文件 prog2l 时，它利用 7.9 节中讨论过的技术，加载部分链接的可执行文件 prog2l。
接着，它注意到 prog2l 包含一个 `.interp` 节，这一节包含动态链接器的路径名，动态链接器本身就是一个共享目标（如在 Linux 系统上的 `ld-linux.so`）. 加载器不会像它通常所做地那样将控制传递给应用，而是加载和运行这个动态链接器。
然后，动态链接器通过执行下面的重定位完成链接任务：

 - 重定位 `libc.so` 的文本和数据到某个内存段。
 - 重定位 `libvector.so` 的文本和数据到另一个内存段。
 - 重定位 `prog2l` 中所有对由 `libc.so` 和 `libvector.so` 定义的符号的引用。
最后，动态链接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变。

====================================================================================================

这段描述涉及到动态链接过程中的一系列复杂步骤。
让我们更细致地分析这个过程，特别是当涉及到加载一个包含动态库引用的可执行文件（如 `prog2l`）时。

### 加载器的作用

1. **加载部分链接的可执行文件 `prog2l`**:
   - 当你运行一个程序（如 `prog2l`）时，操作系统的加载器首先被激活。
   - 加载器读取可执行文件的头部信息，了解如何将文件的不同部分（代码、数据等）加载到内存中。

2. **检测 `.interp` 节**:
   - 加载器检查可执行文件中的 `.interp` 节。这一节包含了动态链接器（如 `ld-linux.so`）的路径。
   - 这告诉加载器，程序需要动态链接来运行。

### 动态链接器的作用

3. **加载动态链接器**:
   - 接着，加载器加载 `.interp` 中指定的动态链接器到内存中。
   - 在这个阶段，加载器不会直接将控制权交给应用程序，而是先将其交给动态链接器。

4. **动态链接器执行重定位**:
   - 动态链接器现在开始其工作，首先是加载并重定位动态库（如 `libc.so` 和 `libvector.so`）。
   - 它将这些库的代码（文本）和数据段加载到内存的适当位置。
   - 对于每个库，链接器处理重定位表，这是库中对其他地址（函数、变量等）的引用需要被修正的地方。

5. **重定位应用程序的引用**:
   - 链接器还需要处理 `prog2l` 中对这些库中定义的符号的引用。
   - 这意味着，程序中对库函数和变量的所有引用都被修正，指向它们在内存中的实际地址。

6. **控制权转移**:
   - 一旦所有必要的库都被加载并且所有的引用都被正确地重定位，动态链接器将控制权传递给应用程序。
   - 此时，共享库的位置在内存中已固定，且在程序执行过程中不会改变。

### 结果

- 在此过程结束后，`prog2l` 就可以像使用静态链接的函数和数据一样，使用 `libc.so` 和 `libvector.so` 中的函数和数据。
- 这个过程使得 `prog2l` 可以使用最新版本的共享库，而无需重新编译。同时，如果有多个程序使用相同的库，这些库在内存中只需加载一次，从而节省资源。

总的来说，这个动态链接过程是操作系统和动态链接器共同协作的结果，旨在有效地加载和运行动态链接的应用程序，同时确保内存中库的高效使用。

====================================================================================================

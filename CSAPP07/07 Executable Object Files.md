# Executable Object Files
# 可执行目标文件

我们已经看到链接器如何将多个目标文件合并成一个可执行目标文件。
我们的示例 C 程序，开始时是一组 ASCII 文本文件，现在已经被转化为一个二进制文件，且这个二进制文件包含加载程序到内存并运行它所需的所有信息。
图 7-13 概括了一个典型的 ELF 可执行文件中的各类信息。
----------------------
`ELF header`
`Segment header table` -> 将连续的文件节映射到运行时内存段
`.init`     
`.text`                (只读内存段 代码段)
`.rodata`
----------------------
`.data`                (读/写内存段 数据段)
`.bss`
----------------------
`.symtab`       
`.debug`               (不加载到内存的符号表和调试信息)
`.line`
`.strtab`
`Section header table` -> 描述目标文件的节
----------------------

可执行目标文件的格式类似于可重定位目标文件的格式。
ELF 头描述文件的总体格式。它还包括程序的入口点（`entry point`），也就是当程序运行时要执行的第一条指令的地址。
`.text`、`.rodata` 和 `.data` 节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。
`.init` 节定义了一个小函数，叫做 `_init`，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位），所以它不再需要 `.rel` 节。

ELF 可执行文件被设计得很容易加载到内存，可执行文件的连续的片（`chunk`）被映射到连续的内存段。程序头部表（program header table）描述了这种映射关系。
图 7-14 展示了可执行文件 prog 的程序头部表，是由 OBJDUMP 显示的。

 program header table:

~~~shell
Read-only code segment
LOAD off    0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**21
     filesz 0x000000000000069c memsz 0x00000oo000o0069c flags r-x

Read/write data segment
LOAD off    0x0000000000000df8 vaddr 0x0000000000600df8 paddr 0x0000000000600df8 align 2**21
     filesz 0x0000000000000228 memsz 0x0000000000000230 flags rw-
~~~
图 7-14 示例可执行文件 prog 的程序头部表

off：目标文件中的偏移；
vaddr/paddr：内存地址；
align：对齐要求；
filesz：目标文件中的段大小；
memsz：内存中的段大小；
flags：运行时访问权限。

从程序头部表，我们会看到根据可执行目标文件的内容初始化两个内存段。
第 1 行和第 2 行告诉我们第一个段（代码段）有读/执行访问权限，开始于内存地址 `0x400000` 处，总共的内存大小是 `0x69c` 字节，并且被初始化为可执行目标文件的头 `0x69c` 个字节，其中包括 ELF 头、程序头部表以及 .initx.text 和 .rodata 节。

第 3 行和第 4 行告诉我们第二个段（数据段）有读/写访问权限，开始于内存地址 `0x600df8` 处，总的内存大小为 `0x230` 字节，并用从目标文件中偏移 `0xdf8` 处开始的 .data 节中的 `0x228` 个字节初始化。该段中剩下的 8 个字节对应于运行时将被初始化为 0 的 .bss 数据。

(内存对齐要求)
对于任何段 s，链接器必须选择一个起始地址 vaddr，使得
`vaddr mod align = off mod align`
这里，off 是目标文件中段的第一个节的偏移量，align 是程序头部中指定的对齐（  = 0x200000）。例如，图 7-14 中的数据段中
`vaddr mod align = 0x600df8 mod 0x200000 = 0xdf8`
以及
`off mod align = 0xdf8 mod 0x200000 = 0xdf8`
这个对齐要求是一种优化，使得当程序执行时，目标文件中的段能够很有效率地传送到内存中。
原因有点儿微妙，在于虚拟内存的组织方式，它被组织成一些很大的、连续的、大小为 2 的幂的字节片。

第 9 章中你会学习到虚拟内存的知识。

czy-307-thinkcentre-m720q-n000 :: linking_and_loading/CSAPP07/03 ‹master*› » readelf -l example    


Elf 文件类型为 DYN (共享目标文件)
Entry point 0x1060
There are 13 program headers, starting at offset 64

程序头：
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000002d8 0x00000000000002d8  R      0x8
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x00000000000005f8 0x00000000000005f8  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x0000000000000205 0x0000000000000205  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                 0x0000000000000188 0x0000000000000188  R      0x1000
  LOAD           0x0000000000002db8 0x0000000000003db8 0x0000000000003db8
                 0x0000000000000258 0x0000000000000260  RW     0x1000
  DYNAMIC        0x0000000000002dc8 0x0000000000003dc8 0x0000000000003dc8
                 0x00000000000001f0 0x00000000000001f0  RW     0x8
  NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000020 0x0000000000000020  R      0x8
  NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000020 0x0000000000000020  R      0x8
  GNU_EH_FRAME   0x0000000000002014 0x0000000000002014 0x0000000000002014
                 0x000000000000004c 0x000000000000004c  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000002db8 0x0000000000003db8 0x0000000000003db8
                 0x0000000000000248 0x0000000000000248  R      0x1

 Section to Segment mapping:
  段节...
   00     
   01     .interp 
   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 
   03     .init .plt .plt.got .plt.sec .text .fini 
   04     .rodata .eh_frame_hdr .eh_frame 
   05     .init_array .fini_array .dynamic .got .data .bss 
   06     .dynamic 
   07     .note.gnu.property 
   08     .note.gnu.build-id .note.ABI-tag 
   09     .note.gnu.property 
   10     .eh_frame_hdr 
   11     
   12     .init_array .fini_array .dynamic .got

在 ELF（Executable and Linkable Format）文件中，"`Section to Segment mapping`" 显示的是文件中定义的各个节（sections）如何映射到加载到内存中的段（segments）上。
这个映射对于理解程序如何从磁盘加载到内存中并被操作系统执行是非常重要的。

在你给出的例子中，每一行表示一个段，后面跟随的是映射到该段的节的列表。这些段是程序执行时加载到内存中的实体，而节则是编译器用来组织和存储程序数据的单元。

让我们看一下你提到的具体段：

- **段 05** (`05     .init_array .fini_array .dynamic .got .data .bss`): 
    - `.init_array` 和 `.fini_array` 包含程序启动和终止时需要调用的函数指针。
    - `.dynamic` 包含动态链接信息，如所需的共享库和符号。
    - `.got`（全局偏移表）和 `.data` 包含程序的全局和静态数据。
    - `.bss` 包含未初始化的数据，这部分在程序开始时通常被清零。

这些节被组合到同一个段中，因为它们在程序执行期间需要具有相似的内存属性（如读写权限）。
例如，`.data` 和 `.bss` 都需要在运行时被修改，因此它们被放在可写的段中。

总的来说，这个段包含了程序在运行时需要读写的各种数据和表格，如初始化数组、动态链接信息、全局变量等。
这些信息对于程序的运行至关重要，因为它们包含了程序运行时需要使用和修改的数据。 




===================================================================================================
在操作系统和 ELF 文件格式中，内存中分配执行权限的单位确实是段（segment），而不是节（section）。这一点在 ELF 文件的结构和其在内存中的表现中非常明显。

### 段（Segment） vs 节（Section）
- **段（Segment）**:
  - 段是程序加载到内存时的单位。
  - 每个段可以有不同的内存权限，如可读（R）、可写（W）和可执行（X）。
  - 操作系统根据这些段的属性将程序的不同部分加载到内存中，并设置相应的访问权限。

- **节（Section）**:
  - 节是程序编译时的单位，用于组织和存储程序的不同类型的数据。
  - 一个段可以包含多个节，这些节在编译时用于不同的目的，如代码、数据、符号表等。
  - 节的信息主要用于链接和调试，运行时可能不会加载所有节到内存中。

### 执行权限
- 在 ELF 文件中，包含程序代码的段会被赋予执行权限（X）。这通常是代码段（如 `.text`），包含程序的机器指令。
- 数据段（如 `.data`、`.bss`）通常不会被赋予执行权限，以避免安全风险，如缓冲区溢出攻击。

### 结论
- 所以，当操作系统加载一个程序到内存时，它会查看每个段的属性，并根据这些属性来设置内存区域的访问权限。
- 这意味着，在内存中，执行权限是按段来分配的，这对于操作系统的内存保护和安全机制至关重要。
===================================================================================================
# Position-Independent Code (PIC)
# 位置无关代码

共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源。

那么，多个进程是如何共享程序的一个副本的呢？
一种方法是给每个共享库分配一个事先预备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库。虽然这种方法很简单，但是它也造成了一些严重的问题。它对地址空间的使用效率不高，因为即使一个进程不使用这个库，那部分空间还是会被分配出来。它也难以管理。我们必须保证没有片会重叠。每次当一个库修改了之后，我们必须确认已分配给它的片还适合它的大小。如果不适合了，必须找一个新的片。并且，如果创建了一个新的库，我们还必须为它寻找空间。随着时间的进展，假设在一个系统中有了成百个库和库的各个版本库，就很难避免地址空间分裂成大量小的、未使用而又不再能使用的小洞。更糟的是，对每个系统而言，库在内存中的分配都是不同的，这就引起了更多令人头痛的管理问题。

===================================================================================================
想象一个大型的仓库，这个仓库用于存储各种物品。这里的物品可以比作共享库，而仓库的不同区域则类似于程序的地址空间。
如果我们给每种物品（共享库）预留一个固定的存储区域（地址空间片），这种方法看起来简单直观，但会带来几个问题：

1. **空间浪费**：
   - 就像仓库中有些预留区域可能根本没有存放物品一样，程序中的地址空间也会有未使用的部分，尤其是当某个进程不需要某个库时，那块地址空间还是被占用了。

2. **难以管理**：
   - 确保仓库的每个区域不重叠、每个物品都有足够的存储空间，就像在程序中确保每个库的地址空间不冲突、每个库都有足够的地址空间一样困难。如果物品（库）的大小改变，可能需要重新分配一个新的区域。

3. **地址空间碎片化**：
   - 随着时间的推移，仓库中可能出现许多小的、未使用的空间，这些空间无法有效利用。类似地，在程序的地址空间中，随着库的增加和版本更新，可能会产生许多小的、未使用的“空洞”。

4. **缺乏统一性**：
   - 如果每个系统的仓库都以不同的方式存放物品，就会造成管理混乱。同样地，如果每个系统中的库在内存中的分配都不同，也会造成管理上的复杂性。

总的来说，这段内容指出了为每个共享库分配固定地址空间的方法虽然简单
但会带来空间浪费、管理困难、地址空间碎片化和缺乏统一性等问题。在现代操作系统中，
共享库的管理通常采用更灵活、更高效的方式，如使用动态链接和地址空间的按需分配，以避免这些问题。

===================================================================================================

要避免这些问题，现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。
使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。（当然，每个进程仍然会有它自己的读/写数据块。）

可以加载而无需重定位的代码称为位置无关代码（*Position-Independent Code，PIC*）。
用户对 GCC 使用 -fpic 选项指示 GNU 编译系统生成 PIC 代码。共享库的编译必须总是使用该选项。

在一个 x86-64 系统中，对同一个目标模块中符号的引用是不需要特殊处理使之成为 PIC。可以用 PC 相对寻址来编译这些引用，构造目标文件时由静态链接器重定位。然而，对共享模块定义的外部过程和对全局变量的引用需要一些特殊的技巧，接下来我们会谈到。

===================================================================================================

这段内容讨论的是在 x86-64 系统中，如何处理对共享模块（比如共享库）中定义的符号的引用，尤其是在编译为位置无关代码（Position-Independent Code，PIC）时的情况。我们可以将这个过程分解为两部分来理解：

### 1. 同一目标模块内的符号引用
- 在 x86-64 系统中，如果引用（比如函数调用或变量访问）是在同一个目标模块（比如一个单独的可执行文件或一个静态库）内部的，这种引用可以简单地使用程序计数器（PC）相对寻址。
- 这意味着引用的地址是基于当前执行指令的地址计算的，这样的引用在构造目标文件时可以由静态链接器进行重定位。
- 这种方法的优点是效率高，因为它不需要额外的步骤来确定引用的最终地址。

### 2. 对共享模块定义的外部符号的引用
- 然而，当引用在一个共享模块（比如共享库）中定义的外部过程或全局变量时，情况就更复杂了。
- 因为共享库可以被加载到内存中的任意位置，所以不能直接使用基于编译时确定的固定地址的引用。
- 为了处理这种情况，必须使用一些特殊技巧，比如通过间接寻址（比如通过全局偏移量表，`Global Offset Table`，GOT）或通过程序运行时解析地址（通过过程链接表，`Procedure Linkage Table`，PLT）。
- 这些技术允许程序在运行时确定共享库中符号的实际内存地址，从而实现对共享库中定义的函数和变量的正确访问。

简而言之，对于 x86-64 系统中的程序来说，内部模块的符号引用可以直接并高效地处理，但对共享模块定义的外部符号的引用则需要更复杂的技术来确保位置无关和正确的内存访问。这是动态链接和运行时符号解析的基础，是现代操作系统和动态链接库系统的重要组成部分。

===================================================================================================
通俗介绍：

为了通俗解释这个过程，我们可以用一个图书馆和图书管理员的比喻来描述程序如何在运行时解析共享库中的符号（例如函数或变量）的地址。

### 通俗解释

想象一个图书馆，其中存储了大量的书籍（这里的书籍类比于共享库中的函数和变量）。
图书管理员（程序运行时的动态链接器）负责帮助读者（程序）找到他们需要的特定书籍。
图书馆有两个关键的目录系统：一个是图书索引（类比于全局偏移量表，GOT），另一个是特殊请求服务（类比于过程链接表，PLT）。

- **全局偏移量表（GOT）**：假设图书索引里记录了每本书的当前位置。当一个读者想要找一本书时，图书管理员查看索引，得知书的具体位置，并直接把书提供给读者。在程序中，GOT用来存储共享库中符号的实际地址，程序通过查询GOT来获取这些地址。

- **过程链接表（PLT）**：对于一些特别的或者经常变动位置的书籍，图书管理员提供一个特殊请求服务。当读者需要这样的书时，图书管理员先检查是否已经为这本书建立了一个快捷方式（已解析的地址），如果没有，管理员会去找到书的当前位置，并更新快捷方式，以便下次更快找到。在程序中，PLT用于动态解析共享库中函数的地址，特别是那些首次被调用时才解析的函数。

### 详细专业介绍

在专业术语中，这个过程涉及到运行时的符号解析和地址重定位：

1. **全局偏移量表（GOT）**：
   - GOT是一个表，存储在可执行文件或共享对象的数据段中。
   - 它包含了程序运行时需要的地址信息，比如共享库中的全局变量的地址。
   - 当程序需要访问这些全局变量时，它会通过GOT中的地址来访问，而GOT的地址在程序启动时就已经确定。

2. **过程链接表（PLT）**：
   - PLT与函数调用相关，尤其是那些在共享库中定义的函数。
   - 当程序第一次调用一个库中的函数时，它实际上调用的是PLT中的一个入口。
   - 这个PLT入口包含了调用动态链接器的代码，用于查找或加载函数的实际地址。
   - 一旦地址被确定，它就被存储在PLT中，以便后续的函数调用可以直接跳转到正确的地址，而不再需要动态链接器的介入。

总的来说，GOT和PLT是动态链接过程中解决符号地址解析的关键数据结构。它们使得程序能够在运行时正确地访问共享库中的符号，同时提供了一定程度的优化，以减少运行时的符号解析开销。
===================================================================================================

## PIC 数据引用

编译器通过运用以下这个有趣的事实来生成对全局变量的 PIC 引用：
无论我们在内存中的何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变。因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。

想要生成对全局变量 PIC 引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做全局偏移量表（`Global Offset Table，GOT`）。
在 GOT 中，每个被这个目标模块引用的全局数据目标（过程或全局变量）都有一个 8 字节条目。编译器还为 GOT 中每个条目生成一个重定位记录。
在加载时，动态链接器会重定位 GOT 中的每个条目，使得它包含目标的正确的绝对地址。每个引用全局目标的目标模块都有自己的 GOT。

图 7-18 展示了示例 `libvector.so` 共享模块的 GOT。`addvec` 例程通过 `GOT[3]` 间接地加载全局变量 `addcnt` 的地址，然后把 `addcnt` 在内存中加 `1`。这里的关键思想是对 `GOTQ[3]` 的 PC 相对引用中的偏移量是一个运行时常量。

用 GOT 引用全局变量。libvector.so 中的 addvec 例程通过 libvector.so 的 GOT 间接引用了 addcnt
Fixed distance of `0x2008b9` bytes at run time between `GOT[3]` and `addl` instruction
~~~shell
addvec:
    mov 0x2008b9(%rip), % rax   # %rax=*GOT[3]=&addcnt
    addl $0x1,(%rax)            # addcnt++
~~~

因为 `addcnt` 是由 `libvector.so` 模块定义的，编译器可以利用代码段和数据段之间不变的距离，产生对 addcnt 的直接 PC 相对引用，并增加一个重定位，让链接器在构造这个共享模块时解析它。不过，如果 addcnt 是由另一个共享模块定义的，那么就需要通过 GOT 进行间接访问。在这里，编译器选择采用最通用的解决方案，为所有的引用使用 GOT。


## PIC 函数调用

假设程序调用一个由共享库定义的函数。
编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。
正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。
不过，这种方法并不是 PIC，因为它需要链接器修改调用模块的代码段，GNU 编译系统使用了一种很有趣的技术来解决这个问题，称为延迟绑定（`lazy binding`），将过程地址的绑定推迟到第一次调用该过程时

使用延迟绑定的动机是对于一个像 `libc.so` 这样的共享库输出的成百上千个函数中，一个典型的应用程序只会使用其中很少的一部分。
把函数地址的解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。
第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接的内存引用。

延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是：*GOT* 和过程链接表（*Procedure Linkage Table*，PLT）。如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的 GOT 和 PLT。GOT 是数据段的一部分，而 PLT 是代码段的一部分。

图 7-19 展示的是 PLT 和 GOT 如何协作在运行时解析函数的地址。首先，让我们检查一下这两个表的内容。

图片见： https://hansimov.gitbook.io/csapp/part2/ch07-linking/7.12-position-independent-code

- 过程链接表（PLT）。
PLT 是一个数组，其中每个条目是 16 字节代码。
PLT[0] 是一个特殊条目，它跳转到动态链接器中。
    `PLT[0]: Call dynamic lincker`
每个被可执行程序调用的库函数都有它自己的 PLT 条目。每个条目都负责调用一个具体的函数。`PLT[1]`（图中未显示）调用系统启动函数（`__libc_start_main`），它初始化执行环境，调用 `main` 函数并处理其返回值从 `PLT[2]` 开始的条目调用用户代码调用的函数。在我们的例子中，`PLT[2]` 调用 addvec，`PLT[3]`（图中未显示）调用 printf。


- 全局偏移量表（GOT）。
正如我们看到的，`GOT` 是一个数组，其中每个条目是 8 字节地址。和 PLT 联合使用时，`GOT[O]` 和 `GOT[1]` 包含动态链接器在解析函数地址时会使用的信息。

`GOT[0]: addr of .dynamic`
`GOT[1]: addr of reloc entries`
`GOT[2]` 是动态链接器在 `ld-linux.so` 模块中的入口点。
其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的 PLT 条目。例如，`GOT[4]` 和 `PLT[2]` 对应于 addvec。初始时，每个 GOT 条目都指向对应 PLT 条目的第二条指令。

图 7-19a 展示了 GOT 和 PLT 如何协同工作，在 addvec 被第一次调用时，延迟解析它的运行时地址：

 - 第 1 步。不直接调用 `addvec`，程序调用进入 `PLT[2]`，这是 addvec 的 PLT 条目。

 - 第 2 步。第一条 PLT 指令通过 `GOT[4]` 进行间接跳转。因为每个 GOT 条目初始时都指向它对应的 PLT 条目的第二条指令，这个间接跳转只是简单地把控制传送回 `PLT[2]` 中的下一条指令。

 - 第 3 步。在把 addvec 的 ID（0x1）压入栈中之后，PLT[2] 跳转到 PLT[0]。

 - 第 4 步。`PLT[0]` 通过 `GOT[1]` 间接地把动态链接器的一个参数压入栈中，然后通过 `GOT[2]` 间接跳转进动态链接器中。动态链接器使用两个栈条目来确定 addvec 的运行时位置，用这个地址重写 `GOT[4]`，再把控制传递给 addvec。

图 7-19b 给出的是后续再调用 addvec 时的控制流：
 - 第 1 步。和前面一样，控制传递到 PLT[2]。
 - 第 2 步。不过这次通过 GOT[4] 的间接跳转会将控制直接转移到 addvec。


 这段话描述的是在使用动态链接库时，程序如何通过过程链接表（PLT）和全局偏移量表（GOT）来调用共享库（比如 `libvector.so`）中的函数（比如 `addvec`）。
 这是一个复杂的过程，涉及到运行时的符号解析和地址重定位。我将先通俗解释，然后进行详细的技术性描述。

### 通俗解释

假设你要通过电话联系一个朋友（调用 `addvec` 函数），但是你不知道他的号码。
你首先查看你的电话簿（PLT），这里记录了一个服务中心（动态链接器）的号码，服务中心知道如何找到你朋友的号码。

1. **第一步**：你拨打服务中心的号码（程序调用进入 `PLT[2]`，`addvec` 的 PLT 条目）。

2. **第二步**：服务中心告诉你，他们需要一点时间来查找号码，并让你稍后再打这个号码（PLT 指令通过 GOT 进行间接跳转，但初始时跳回 PLT 中的下一条指令）。

3. **第三步**：你再次拨打服务中心的号码，并提供你朋友的名字（程序通过 PLT 跳转到 PLT[0]，同时将 `addvec` 的 ID 压入栈中）。

4. **第四步**：服务中心找到了你朋友的号码，并告诉你，以后可以直接拨打这个号码（动态链接器重写 GOT 条目，并将控制传递给 `addvec`）。

### 技术性描述

1. **第一步**：
   - 程序不是直接调用 `addvec`，而是调用它在 PLT 中的条目，`PLT[2]`。
   - 这是因为 `addvec` 的实际地址在程序开始运行时还未知。

2. **第二步**：
   - `PLT[2]` 的第一条指令通过 `GOT[4]` 进行间接跳转。
   - 初始时，`GOT[4]` 指向 `PLT[2]` 中的下一条指令，因此这个跳转简单地继续执行 `PLT[2]` 中的下一条指令。

3. **第三步**：
   - `PLT[2]` 现在将 `addvec` 的标识符压入栈中，并跳转到 `PLT[0]`。
   - 这是一个准备步骤，用于调用动态链接器并让它解析 `addvec` 的实际地址。

4. **第四步**：
   - `PLT[0]` 通过 `GOT[1]` 将一个参数压入栈中，然后通过 `GOT[2]` 跳转到动态链接器。
   - 动态链接器使用栈中的信息来解析 `addvec` 的实际运行时地址，然后将这个地址写入 `GOT[4]`，替换原来指向 `PLT[2]` 的地址。
   - 接下来，动态链接器将控制权传递给 `addvec`，现在位于其真正的运行时地址。

这个过程确保了程序可以在运行时动态地解析并调用共享库中的函数，而无需在编译时知道这些函数的具体地址。
这种机制是动态链接库系统的核心，允许共享代码在多个程序间重用，同时提供了灵活的更新和维护方式。


在动态链接的过程中，`PLT[0]` 通过 `GOT[1]` 将一个参数压入栈中，然后通过 `GOT[2]` 跳转到动态链接器的操作是动态链接过程中的关键步骤。这个过程的目的是为了在运行时解析共享库中函数的实际地址。
压栈操作在这里是必要的，因为它提供了动态链接器所需的信息来正确地解析函数地址。以下是详细解释：

### 为什么要压栈

1. **传递信息给动态链接器**：
   - 当程序第一次调用一个共享库中的函数时，它需要动态链接器的帮助来解析这个函数的实际地址。
   - 动态链接器需要知道哪个函数被调用，以及它属于哪个共享库。这些信息通过压栈操作传递给动态链接器。

2. **标识符和上下文信息**：
   - 压入栈中的参数通常包括函数的标识符或名称，以及可能的其他上下文信息。
   - 这些信息对动态链接器来说是必需的，因为它需要根据这些信息在共享库中查找正确的函数地址。

3. **保持调用约定**：
   - 在许多系统中，调用函数时传递参数的标准方式是通过栈。
   - 即使是动态链接器也遵循这种调用约定，因此将信息压入栈中是一种符合约定的方法来传递数据。

### 动态链接过程的具体步骤

- 当 `PLT[0]` (*call dynamic linker*) 被执行时，它首先通过 `GOT[1] ` (*addr of reloc entries*) 将必要的信息（比如调用的函数的标识符）压入栈中。
- 然后，它通过 `GOT[2]` (*addr of dynamic linker*) 进行间接跳转到动态链接器。`GOT[2]` 通常包含动态链接器的地址。
- 动态链接器接收这些信息，确定被调用函数的真实地址，并更新 `GOT` 条目，以便下次同一个函数被调用时可以直接跳转到这个地址，而不需要再次通过动态链接器。

这种机制允许共享库在多个程序之间共享，同时还提供了在不重新编译程序的情况下更新共享库的能力。这是现代操作系统动态链接和共享库功能的基础。




在动态链接过程中，`GOT[4]` 初始时指向 `PLT[2]` 中的下一条指令是为了实现“懒绑定”（*lazy binding*）。
懒绑定是一种优化技术，它延迟函数地址的解析直到该函数首次被调用。这种方式避免了在程序启动时进行大量不必要的符号解析，从而加快了程序的启动时间。以下是详细解释：

### 懒绑定的工作机制

1. **初始状态**：
   - 当程序首次启动时，`GOT` 条目（例如 `GOT[4]`）并不包含外部函数（如 `addvec`）的实际地址。
   - 相反，它们被初始化为指向 `PLT` 中相应条目的一部分（在这个例子中是 `PLT[2]` 的下一条指令）。

2. **首次调用函数**：
   - 当程序第一次调用 `addvec` 函数时，它实际上跳转到 `PLT[2]`。
   - `PLT[2]` 的第一条指令是通过 `GOT[4]` 进行的间接跳转。由于 `GOT[4]` 初始时指向 `PLT[2]` 的下一条指令，这个跳转实际上只是继续执行 `PLT[2]` 中的剩余部分。

3. **跳转到动态链接器**：
   - `PLT[2]` 的剩余部分将执行一系列操作，包括将必要信息压入栈中，然后跳转到 `PLT[0]`。
   - `PLT[0]` 会进一步调用动态链接器来解析 `addvec` 的实际运行时地址。

4. **更新 GOT**：
   - 动态链接器找到 `addvec` 的地址后，会将这个地址写入 `GOT[4]`。
   - 这样，下次程序再次调用 `addvec` 时，`GOT[4]` 将直接指向正确的函数地址，从而避免重复调用动态链接器。

### 为什么采用这种设计

这种设计的关键优点是减少了启动时的开销。
只有在函数实际被用到时，动态链接器才会解析其地址。这不仅加快了程序的启动时间，也减少了内存使用，因为没有用到的函数永远不会被解析。这是现代操作系统中常见的一种优化技术，尤其是在有大量共享库的系统中。
在程序编译和链接的上下文中，"PLT" 和 "GOT" 分别指代程序链接表（Procedure Linkage Table）和全局偏移表（Global Offset Table）。
这两个结构是在处理动态链接库（Dynamic Link Libraries, DLLs）或共享对象（Shared Objects, SOs）时非常重要的。

1. **程序链接表（PLT）**:
   - PLT是用于解决在动态链接或运行时链接中遇到的符号地址问题的一种机制。
   - 当一个程序调用一个不在其可执行文件中的函数（如共享库中的函数）时，PLT提供了一个跳转指令的位置，该位置在运行时被解析为实际函数的地址。
   - 这允许程序在编译时不需要知道共享库中函数的实际内存地址。

2. **全局偏移表（GOT）**:
   - GOT是一种数据结构，用于管理动态链接环境中的全局变量和静态变量的地址。
   - 当一个程序需要访问不在其静态内存区域的变量（如共享库中的全局变量）时，它会使用GOT中的条目来找到这些变量的地址。
   - GOT使得程序在运行时可以正确地访问和修改这些变量，而无需在编译时就确定它们的地址。

PLT和GOT都是动态链接过程中解决符号解析问题的关键结构，它们使得可执行文件可以在运行时与共享库相连，而不是在编译时静态链接。
这种机制降低了程序的内存占用，并增加了软件的模块化和可重用性。
通过使用PLT和GOT，操作系统能够有效地管理和链接程序中使用的各种库和模块，即使这些库在程序编译时并不是完全已知的。


让我们通过一个具体的例子来深入理解程序链接表（PLT）和全局偏移表（GOT）的作用。

假设我们有一个C语言程序，它调用了标准C库（例如，`libc`）中的函数 `printf`，这个函数不是程序自身定义的，而是来自于一个共享库。
在这个例子中，我们将看到PLT和GOT如何协助处理这种动态链接。

### 示例代码：

```c
#include <stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
```

在这个简单的程序中，`printf` 函数是从标准C库动态链接的。

### PLT和GOT的作用：

1. **程序链接表（PLT）的作用**:
    - 当程序调用 `printf` 时，它实际上首先跳转到PLT中的一个入口。
    - 这个PLT入口包含了跳转到`printf`函数实际地址的指令。但在程序第一次执行时，这个地址可能还不是已知的。
    - 在程序首次调用`printf`时，PLT入口将通过动态链接器解析`printf`的真实地址，然后将其更新在PLT中。以后的调用将直接跳转到这个地址。

2. **全局偏移表（GOT）的作用**:
    - GOT存储了程序中使用的全局变量和静态变量的地址，这些地址在程序运行时可能会被修改。
    - 在我们的例子中，如果`printf`函数或者其他库函数需要访问或修改全局变量，它们将通过GOT来实现这一点。
    - GOT为每个全局变量提供了一个固定的位置，不管这个变量实际上在内存中的位置是否已经确定或者发生了变化。

### 动态链接的过程：

- 当程序启动时，动态链接器（例如Linux上的`ld-linux.so`）加载程序和它依赖的共享库。
- 链接器解析共享库中函数和变量的实际地址，并更新PLT和GOT中的条目。
- 程序在运行时通过PLT和GOT中的条目访问函数和变量，确保即使它们的实际地址在内存中发生了变化，程序也能正确地访问到它们。

这个过程使得程序能够在不知道共享库中函数和变量具体地址的情况下运行，同时允许在程序运行时加载和更新这些库，这是动态链接的一个重要特点。


在一个动态链接的程序中，全局偏移表（GOT）和程序链接表（PLT）的初始化发生在程序的加载和运行时阶段，主要由动态链接器处理。以下是详细的解释：

### 全局偏移表（GOT）的初始化：

1. **加载阶段**:
   - 当程序启动时，动态链接器（如Linux上的 `ld-linux.so`）负责加载程序和它所依赖的所有动态库（如共享对象.so文件或动态链接库.dll文件）。
   - 在这个过程中，链接器读取可执行文件和共享库的头部信息，找到GOT并确定其大小和位置。

2. **重定位**:
   - 动态链接器接着进行重定位，这包括更新GOT中的每个条目。重定位是基于实际加载到内存中的共享对象的地址。
   - 对于全局和静态变量的访问，GOT提供了一个中间层，允许程序代码通过GOT条目来访问这些变量的实际地址。

3. **运行时更新**:
   - 如果程序运行过程中加载了新的共享库（例如，通过 `dlopen`），则动态链接器将更新GOT以反映新库中的符号地址。

### 程序链接表（PLT）的初始化：

1. **加载阶段**:
   - 与GOT类似，PLT在程序加载阶段由动态链接器处理。链接器确定PLT的位置和大小，并将PLT条目设置为指向链接器的一部分，这部分将负责解析这些函数的实际地址。

2. **惰性解析**:
   - 动态链接器通常采用所谓的“惰性解析”（lazy binding）策略来处理PLT条目。这意味着函数的实际地址只有在第一次调用时才被解析和填充。
   - 在第一次函数调用时，PLT条目将控制转移到动态链接器，链接器解析出函数的实际地址，然后将该地址写回PLT中相应的条目。这样，后续对该函数的调用将直接跳转到正确的地址。

3. **运行时优化**:
   - 通过这种方法，PLT的初始化和更新可以优化运行时性能，因为只有实际使用的函数才会被解析，减少了启动时间和内存占用。

在实践中，PLT和GOT的具体实现和优化可能因操作系统和处理器架构的不同而有所不同。但总体上，它们都是动态链接过程中非常关键的组成部分，确保了程序可以高效地使用动态库。


要在实际的系统中查看和实践PLT（程序链接表）和GOT（全局偏移表），你可以通过以下步骤进行操作。以Linux操作系统为例，你可以使用工具如 `objdump` 和 `readelf` 来检查可执行文件和共享库的PLT和GOT表项。

### 实践步骤：

1. **编写一个简单的C程序**：

    首先，创建一个简单的C程序，比如调用 `printf` 函数的程序。

    ```c
    // file: hello.c
    #include <stdio.h>

    int main() {
        printf("Hello, world!\n");
        return 0;
    }
    ```

2. **编译这个程序**：

    使用 `gcc` 编译这个程序：

    ```bash
    gcc -o hello hello.c
    ```

3. **使用 `objdump` 查看PLT**：

    `objdump` 工具可以用来查看可执行文件的PLT。运行以下命令：

    ```bash
    objdump -d -j .plt hello
    ```

    这将展示 `hello` 程序的PLT部分。在输出中，你将看到 `printf` 函数的PLT入口。
========================================================================================================= 
hello：     文件格式 elf64-x86-64


Disassembly of section .plt:

0000000000001020 <.plt>:
    1020:       ff 35 9a 2f 00 00       pushq  0x2f9a(%rip)        # 3fc0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:       f2 ff 25 9b 2f 00 00    bnd jmpq *0x2f9b(%rip)        # 3fc8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102d:       0f 1f 00                nopl   (%rax)
    1030:       f3 0f 1e fa             endbr64 
    1034:       68 00 00 00 00          pushq  $0x0
    1039:       f2 e9 e1 ff ff ff       bnd jmpq 1020 <.plt>
    103f:       90                      nop
=========================================================================================================    

4. **使用 `readelf` 查看GOT**：

    使用 `readelf` 工具可以查看GOT：

    ```bash
    readelf -r hello
    ```

    这将显示所有重定位条目，包括GOT条目。你可以在输出中找到与 `printf` 函数相关的条目。
    
========================================================================================================= 
重定位节 '.rela.dyn' at offset 0x520 contains 8 entries:
  偏移量          信息           类型           符号值        符号名称 + 加数
000000003db8  000000000008 R_X86_64_RELATIVE                    1140
000000003dc0  000000000008 R_X86_64_RELATIVE                    1100
000000004008  000000000008 R_X86_64_RELATIVE                    4008
000000003fd8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0
000000003fe0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
000000003fe8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
000000003ff0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0
000000003ff8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0

重定位节 '.rela.plt' at offset 0x5e0 contains 1 entry:
  偏移量          信息           类型           符号值        符号名称 + 加数
000000003fd0  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0        
========================================================================================================= 

5. **动态链接器的作用**：

    当你运行这个程序时，动态链接器（在Linux上通常是 `ld-linux.so`）会填充PLT和GOT的实际地址。这通常是在后台自动完成的，但你可以使用 `LD_DEBUG` 环境变量来观察这个过程：

    ```bash
    LD_DEBUG=symbols ./hello
    ```

    这个命令会显示动态链接器如何处理符号解析，包括如何处理PLT和GOT中的符号。

通过上述步骤，你可以在实际的Linux系统中直观地查看和理解PLT和GOT的工作原理。这是一个非常实用的方式来学习和理解动态链接的过程。


这个输出是在运行一个使用 `LD_DEBUG=symbols` 环境变量编译的 `hello` 程序时产生的。
它显示了动态链接器（在这种情况下是Linux系统的链接器）如何解析和查找程序中引用的各种符号。
这里的符号可以是函数、全局变量或其他类型的符号，它们可以在程序自身或其依赖的共享库中定义。

### 解读输出：

1. **符号查找过程**:
   - 每一行显示了一个符号的查找过程。
   例如，`symbol=malloc;  lookup in file=./hello [0]` 表示动态链接器正在尝试找到 `malloc` 函数的地址。
   它首先在 `hello` 程序中查找（`file=./hello`），如果找不到，它会继续在其他共享库中查找，比如在 `/lib/x86_64-linux-gnu/libc.so.6`。

2. **符号来源**:
   - 输出中的 `[0]` 表示符号最终在哪里找到。如果是在 `hello` 程序中找到，它将显示为 `[0]`。如果是在共享库中找到（如 `libc.so.6`），则显示相应的库名称。

3. **PLT和GOT的角色**:
   - 尽管这个输出没有直接显示PLT和GOT的条目，但它展示了动态链接器如何解析这些符号，这是PLT和GOT初始化过程的一部分。
   例如，当 `hello` 程序第一次调用 `malloc`（或任何其他库函数）时，链接器会通过PLT来解析其地址，并在必要时更新GOT条目。

4. **初始化和控制转移**:
   - 输出的最后部分包括一些特殊的符号解析和程序初始化及结束的步骤。例如，`calling init: /lib/x86_64-linux-gnu/libc.so.6` 表示正在初始化 `libc` 库，而 `transferring control: ./hello` 表示控制权被传递给 `hello` 程序。

### 结论：

这个输出为你提供了一个动态链接器在程序运行时如何处理符号解析的窗口。它揭示了PLT和GOT在动态链接过程中的重要作用，以及动态链接器如何管理这一过程。通过这种方式，程序能够在运行时动态地连接到它所需的库，而无需在编译时静态地链接它们。这提高了灵活性并减少了程序的总体内存占用。